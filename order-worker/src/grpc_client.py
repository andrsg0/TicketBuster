"""
gRPC client for communicating with Catalog Service.
Calls CommitSeat RPC to finalize seat purchases.
"""
import logging
import grpc
from dataclasses import dataclass
from typing import Optional

from .config import settings

# Note: These will be generated by grpcio-tools from inventory.proto
# Run: python -m grpc_tools.protoc -I../proto --python_out=./src/generated --grpc_python_out=./src/generated ../proto/inventory.proto ../proto/common.proto
try:
    from .generated import inventory_pb2
    from .generated import inventory_pb2_grpc
    GRPC_AVAILABLE = True
except ImportError:
    GRPC_AVAILABLE = False
    inventory_pb2 = None
    inventory_pb2_grpc = None

logger = logging.getLogger(__name__)


@dataclass
class CommitSeatResult:
    """Result from CommitSeat RPC call."""
    success: bool
    message: str
    seat_status: Optional[str] = None
    committed_at: Optional[str] = None


class CatalogClient:
    """
    gRPC client for Catalog Service's InventoryService.
    Handles connection management and CommitSeat RPC calls.
    """
    
    def __init__(self, address: str = None):
        """
        Initialize client with target address.
        
        Args:
            address: gRPC server address (host:port). Defaults to settings.
        """
        self.address = address or settings.grpc_catalog_address
        self._channel: Optional[grpc.Channel] = None
        self._stub = None
        logger.info(f"CatalogClient initialized for {self.address}")
    
    def connect(self):
        """Establish gRPC channel and create stub."""
        if not GRPC_AVAILABLE:
            logger.warning("gRPC stubs not available - running in mock mode")
            return
            
        try:
            # Create insecure channel (use secure in production)
            self._channel = grpc.insecure_channel(
                self.address,
                options=[
                    ('grpc.keepalive_time_ms', 30000),
                    ('grpc.keepalive_timeout_ms', 10000),
                    ('grpc.keepalive_permit_without_calls', True),
                ]
            )
            self._stub = inventory_pb2_grpc.InventoryServiceStub(self._channel)
            logger.info(f"Connected to Catalog Service at {self.address}")
        except Exception as e:
            logger.error(f"Failed to connect to Catalog Service: {e}")
            raise
    
    def disconnect(self):
        """Close gRPC channel."""
        if self._channel:
            self._channel.close()
            self._channel = None
            self._stub = None
            logger.info("Disconnected from Catalog Service")
    
    def commit_seat(
        self,
        seat_id: int,
        user_id: str,
        order_uuid: str,
        amount_paid: float
    ) -> CommitSeatResult:
        """
        Commit a seat purchase via gRPC.
        
        Args:
            seat_id: ID of the seat to commit
            user_id: UUID of the user purchasing
            order_uuid: Order UUID for traceability
            amount_paid: Amount paid for validation
            
        Returns:
            CommitSeatResult with success status and message
        """
        if not GRPC_AVAILABLE:
            # Mock mode for development without gRPC stubs
            logger.warning("gRPC not available - returning mock success")
            return CommitSeatResult(
                success=True,
                message="Mock commit successful (gRPC stubs not generated)",
                seat_status="sold"
            )
        
        if not self._stub:
            self.connect()
        
        try:
            # Create request
            request = inventory_pb2.CommitSeatRequest(
                seat_id=seat_id,
                user_id=user_id,
                order_uuid=order_uuid,
                amount_paid=amount_paid
            )
            
            # Call RPC with timeout
            response = self._stub.CommitSeat(request, timeout=30.0)
            
            logger.info(
                f"CommitSeat response: success={response.success}, "
                f"message={response.message}"
            )
            
            return CommitSeatResult(
                success=response.success,
                message=response.message,
                seat_status=response.seat_status if hasattr(response, 'seat_status') else None,
                committed_at=str(response.committed_at) if hasattr(response, 'committed_at') else None
            )
            
        except grpc.RpcError as e:
            status_code = e.code()
            details = e.details()
            logger.error(f"gRPC error in CommitSeat: {status_code} - {details}")
            
            return CommitSeatResult(
                success=False,
                message=f"gRPC error: {status_code.name} - {details}"
            )
        except Exception as e:
            logger.error(f"Unexpected error in CommitSeat: {e}")
            return CommitSeatResult(
                success=False,
                message=f"Unexpected error: {str(e)}"
            )
    
    def health_check(self) -> bool:
        """Check gRPC channel connectivity."""
        if not GRPC_AVAILABLE:
            return True  # Mock mode always healthy
            
        if not self._channel:
            return False
            
        try:
            # Check channel state
            state = self._channel._channel.check_connectivity_state(True)
            return state in [grpc.ChannelConnectivity.READY, grpc.ChannelConnectivity.IDLE]
        except Exception as e:
            logger.error(f"gRPC health check failed: {e}")
            return False
    
    def __enter__(self):
        """Context manager entry."""
        self.connect()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.disconnect()
        return False
